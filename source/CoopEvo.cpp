#include "CoopEvo.h"
#include "Population_Kiter.h"
#include <queue>
#include <random>
#include <utility> 
#include "Common.h"
using namespace SparCraft;

CoopEvo::CoopEvo(size_t mu, size_t lambda, size_t epoch, size_t evalIter)
	: _mu(mu),
	_lambda(lambda),
	_popSize(mu + lambda),
	_epoch(epoch),
	_evalIter(evalIter) {}

void CoopEvo::initRandomWeights(std::vector<Array<double, Constants::Num_Params>>& weights) {
	std::random_device rd; // get a random seed from the OS entropy device
	std::mt19937_64 eng(rd()); // use the 64-bit Mersenne Twister 19937 generator with the rd seed
	std::uniform_real_distribution<double> distr(0, 1); // define the distribution

	for (size_t i = 0; i < 4; ++i) {
		Array<double, Constants::Num_Params> w;
		w.init(0);
		weights.push_back(w);
	}

	// map the random number generated by the Mersenne engine to the uniform distribution
	// and add to array: pretty sketchy way to add to Array class...
	for (size_t d = 0; d < weights.size(); ++d) {
		for (size_t i = 0; i < weights[d].capacity(); ++i) { weights[d][i] = distr(eng); }
	}
}

// initialize method for population of many KiterEMP
void CoopEvo::initialize(const GameState& state, PlayerPtr & p1, PlayerPtr & p2) {
	Player_KiterEMP* kiter = dynamic_cast<Player_KiterEMP *>(p1.get());
	kiter->switchOnOffline();
	for (size_t i = 0; i < _popSize; ++i) {
		std::vector<Array<double, Constants::Num_Params>> weights;
		this->initRandomWeights(weights);
		kiter->setWeights(weights);
		int score = this->eval(state, p1, p2);
		ChromosomeEMP c(weights, score);
		_genePool.push_back(c);
	}
}

// mutate method
ChromosomeEMP CoopEvo::mutate(const ChromosomeEMP& c, const GameState & state, PlayerPtr & p1, PlayerPtr & p2) const {
	// Set up mutation delta
	std::random_device rd; 
	std::mt19937_64 eng(rd()); 
	std::normal_distribution<double> deltaDistr(0, 0.1);
	
	ChromosomeEMP res = c;
	Player_KiterEMP* kiterEmp = dynamic_cast<Player_KiterEMP *>(p1.get());
	kiterEmp->switchOnOffline();

	// Apply mutation to weights
	//auto weights = res.first;
	for (size_t d = 0; d < res.first.size(); ++d) {
		for (size_t i = 0; i < res.first[d].capacity(); ++i) {
			res.first[d][i] += deltaDistr(eng);
			kiterEmp->setWeights(res.first);
			res.second = this->eval(state, p1, p2);
		}
	}

	return res;
}

// Find the average score of a kiter with a given safeDist
int CoopEvo::eval(const GameState & state, PlayerPtr & p1, PlayerPtr & p2) const {
	int kiterScore = 0;
	Game g(state, p1, p2, 1000);
	g.play();
	kiterScore = g.getState().evalLTD2(Players::Player_One);
	return kiterScore;
}

void CoopEvo::printPool() const {
	for (auto it = _genePool.begin(); it != _genePool.end(); it++) {
		std::cout << "\nWeights:\n";
		for (auto w : it->first) {
			std::cout << w << "\n";
		}
		std::cout << "Score: " << it->second << "\n";
	}
}

void CoopEvo::writePoolResult() const {
	// result data for each epoch
	std::ofstream poolRes;
	poolRes.open("kiterEMP/poolRes.csv");

	for (auto it = _genePool.begin(); it != _genePool.end(); it++) {
		poolRes << "\nGene " << (it - _genePool.begin()) << "\n";
		poolRes << "Weights:\n";
		for (auto w : it->first) {
			poolRes << w << "\n";
		}
		poolRes << "Score: " << it->second << "\n";
	}
}

void CoopEvo::writeFinalResult(const ChromosomeEMP& c) const {
	std::cout << "Evolution complete. Writing final result...\n";
	// result data for each epoch
	std::ofstream finalRes;
	finalRes.open("kiterEMP/finalRes.txt");

	for (auto it = c.first.begin(); it != c.first.end(); it++) {
		for (size_t i = 0; i < it->size(); ++i) {
			finalRes << it->get(i) << " ";
		}
		finalRes << "\n";
	}
	finalRes.close();
}

void CoopEvo::printChrom(const ChromosomeEMP& c, std::ostream& os) const {
	for (auto w : c.first) {
		os << w << "\n";
	}
	os << "Score: " << c.second << "\n";
}

// EVOLUTION STRATEGY: http://www.cleveralgorithms.com/nature-inspired/evolution/evolution_strategies.html
void CoopEvo::evolveParams(const GameState & state, PlayerPtr & p1, PlayerPtr & p2) {
	ChromosomeEMP bestGene;

	// result data for each epoch
	std::ofstream epochDat;
	epochDat.open("kiterEMP/epochDat.csv");
	epochDat << "epoch, score\n";

	// initialize and evaluate the baseline population 
	this->initialize(state, p1, p2);
	//this->printPool();
	this->writePoolResult();

	bestGene = _genePool[0];
	// main evolution loop
	for (size_t e = 0; e < _epoch; ++e) {
		//epochDat << "\n============================== GEN " << e << " ==============================\n";
 		// remove lambda worst
		std::sort(_genePool.begin(), _genePool.end(), KiterComparator(false));
		for (size_t l = 0; l < _lambda; ++l) {
			_genePool.pop_back();
		}
		//epochDat << "After removing lambda " << _lambda << " - genepool size = " << _genePool.size() << "\n";

		// re-mutate mu best
		for (size_t m = 0; m < _mu; ++m) {
			ChromosomeEMP c = _genePool[m];
			ChromosomeEMP mutated = mutate(c, state, p1, p2);
			_genePool.push_back(mutated);
			//epochDat << "\nMutated chrom " << m << "\n";
			//this->printChrom(mutated, epochDat);
		}
		//epochDat << "After remutating mu " << _mu << " - genepool size = " << _genePool.size() << "\n";


		std::sort(_genePool.begin(), _genePool.end(), KiterComparator(false));
		bestGene = _genePool[0];
		
		//epochDat << "\nEnd of gen " << e << " - Best params:\n";
		//this->printChrom(bestGene, epochDat);
		epochDat << e << ", " << bestGene.second << "\n";

		//std::cout << "\nEnd of gen " << e << " - Best params:\n";
		//this->printChrom(bestGene, std::cout);
	}

	epochDat.close();

	// Write result to a .txt file
	// Instead of returning result from evo like in KiterDPSEvo 
	this->writeFinalResult(bestGene);
}

