#include "CoopEvo.h"
#include <queue>
#include <random>
#include <utility> 
#include "Common.h"
using namespace SparCraft;

CoopEvo::CoopEvo(size_t mu, size_t lambda, size_t epoch, size_t evalIter)
	: _mu(mu),
	_lambda(lambda),
	_popSize(mu + lambda),
	_epoch(epoch),
	_evalIter(evalIter) {}

void CoopEvo::initWeights(Array<double, Constants::Num_Params>& w) {
	std::random_device rd; // get a random seed from the OS entropy device
	std::mt19937_64 eng(rd()); // use the 64-bit Mersenne Twister 19937 generator with the rd seed
	std::uniform_real_distribution<double> distr(0, 1); // define the distribution

	// map the random number generated by the Mersenne engine to the uniform distribution
	// and add to array: pretty sketchy way to add to Array class...
	for (size_t i = 0; i < w.capacity(); ++i) { w.add(distr(eng)); }
}

// initialize method for population of many KiterDPSEvo
void CoopEvo::initialize(const GameState& state, PlayerPtr & p1, PlayerPtr & p2) {
	Player_KiterEMP* kiter = dynamic_cast<Player_KiterEMP *>(p1.get());
	kiter->switchOnOffline();
	for (size_t i = 0; i < _popSize; ++i) {
		Array<double, Constants::Num_Params> w;
		this->initWeights(w);
		kiter->setWup(w);
		//int score = _eval(state, p1, p2);
		int score = 0;
		ChromosomeEMP c(w, score);
		_genePool.push_back(c);
	}
}

//// mutate method
//Chromosome CoopEvo::mutate(size_t mutationDelta, const Chromosome& c, const GameState & state, PlayerPtr & p1, PlayerPtr & p2) {
//	Chromosome res;
//	Player_KiterDPSEvo* kiter = dynamic_cast<Player_KiterDPSEvo *>(p1.get());
//	kiter->switchOnOffline();
//
//	// Consider mutation by wiggling the parent dist +/- mutationDelta
//	if (c.first < mutationDelta) {
//		kiter->setSafeDist(0);
//	}
//	else {
//		kiter->setSafeDist(c.first - mutationDelta);
//	}
//	int leftScore = eval(state, p1, p2);
//
//	kiter->setSafeDist(c.first + mutationDelta);
//	int rightScore = eval(state, p1, p2);
//
//	// Choose the offspring with better fitness eval score
//	res.first = (leftScore > rightScore) ? (c.first < mutationDelta ? 0 : (c.first - mutationDelta)) : (c.first + mutationDelta);
//	res.second = (leftScore > rightScore) ? leftScore : rightScore;
//	return res;
//}

//// Find the average score of a kiter with a given safeDist
//int CoopEvo::eval(const GameState & state, PlayerPtr & p1, PlayerPtr & p2) {
//	//std::cout << "\n \n Evaluating d = " << dynamic_cast<Player_KiterDPSEvo *>(p1.get())->getSafeDist() << "\n";
//	int kiterScore = 0;
//	//for (int i = 0; i < _evalIter; ++i) {
//	Game g(state, p1, p2, 1000);
//	g.play();
//	//kiterScore += g.getState().evalLTD2(Players::Player_One);
//	kiterScore = g.getState().evalLTD2(Players::Player_One);
//	//}
//	//kiterScore /= _evalIter;
//	return kiterScore;
//}

//bool KiterComparator::operator() (Chromosome lhs, Chromosome rhs) const {
//	if (increasing) {
//		return lhs.second < rhs.second;
//	}
//	return lhs.second > rhs.second;
//}

void CoopEvo::printParams() {
	for (auto it = _genePool.begin(); it != _genePool.end(); it++) {
		std::cout << "(" << it->first << ", S: " << it->second << ") ";
	}
	std::cout << "\n";
}

// EVOLUTION STRATEGY: http://www.cleveralgorithms.com/nature-inspired/evolution/evolution_strategies.html
Array<double, Constants::Num_Params> CoopEvo::evolveParams(const GameState & state, PlayerPtr & p1, PlayerPtr & p2) {
	ChromosomeEMP bestGene;

	//// result data for each epoch
	//std::ofstream epochDat;
	//epochDat.open("epochDat.csv");
	//epochDat << "epoch, score, d\n";

	// initialize population of Kiters to having random safeDist values
	// and evaluate the baseline population 
	this->initialize(state, p1, p2);
	//this->_printParams();

	//bestGene = _genePool[0];
	//// main evolution loop
	//for (size_t e = 0; e < _epoch; ++e) {
	//	// remove lambda worst
	//	std::sort(_genePool.begin(), _genePool.end(), KiterComparator(false));
	//	for (size_t l = 0; l < _lambda; ++l) {
	//		_genePool.pop_back();
	//	}

	//	// re-mutate mu best
	//	for (size_t m = 0; m < _mu; ++m) {
	//		Chromosome c = _genePool[m];
	//		size_t mutationDelta = deltaDistr(eng);
	//		Chromosome mutated = mutate(mutationDelta, c, state, p1, p2);
	//		_genePool.push_back(mutated);
	//	}

	//	std::sort(_genePool.begin(), _genePool.end(), KiterComparator(false));
	//	bestGene = _genePool[0];
	//	//std::cout << "\n End of gen " << e << " - Best d = " << bestGene.first << " with score = " << bestGene.second << "\n";
	//	epochDat << e << "," << bestGene.second << "," << bestGene.first << "\n";
	//	//printDist();
	//}

	//epochDat.close();
	return bestGene.first;
}

